<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualizar Apresentação - Insightflow</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="style.css">
    <style>
        /* Estilos para edição inline */
        .editable {
            position: relative;
            transition: all 0.2s;
        }
        
        .editable:hover {
            background-color: rgba(147, 51, 234, 0.1);
            outline: 2px dashed rgba(147, 51, 234, 0.3);
            outline-offset: 2px;
            cursor: text;
        }
        
        .editable[contenteditable="true"] {
            background-color: rgba(147, 51, 234, 0.15);
            outline: 2px solid rgba(147, 51, 234, 0.5);
            outline-offset: 2px;
        }
        
        .editable[contenteditable="true"]:focus {
            outline: 2px solid rgba(147, 51, 234, 0.8);
            background-color: rgba(147, 51, 234, 0.2);
        }
        
        /* Botão flutuante de salvar */
        .save-button-container {
            position: fixed;
            bottom: 30px;
            right: 30px;
            z-index: 1000;
            animation: slideUp 0.3s ease-out;
        }
        
        @keyframes slideUp {
            from {
                transform: translateY(100px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        /* Preview container */
        .presentation-container {
            background: #f0f0f0;
            padding: 40px 20px;
            min-height: 100vh;
        }
        
        .presentation-container .page {
            margin: 20px auto;
        }
    </style>
</head>
<body class="bg-gray-50 font-sans">
    <div class="min-h-screen">
        <!-- Header -->
        <header class="bg-white border-b border-gray-200 shadow-sm">
            <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4">
                <div class="flex items-center justify-between">
                    <div class="flex items-center gap-4">
                        <button onclick="window.history.back()" class="p-2 hover:bg-gray-100 rounded-lg transition-colors">
                            <i class="fas fa-arrow-left text-gray-700"></i>
                        </button>
                        <div>
                            <h1 id="presentationName" class="text-xl font-bold text-gray-900">Carregando...</h1>
                            <p class="text-sm text-gray-600">Ative o modo edição para personalizar os dados</p>
                        </div>
                    </div>
                    <div class="flex items-center gap-3">
                        <button id="toggleEditBtn" class="px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition-all flex items-center gap-2">
                            <i class="fas fa-edit"></i>
                            Modo Edição
                        </button>
                        <button id="saveBtn" class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-all flex items-center gap-2 hidden">
                            <i class="fas fa-save"></i>
                            Salvar
                        </button>
                        <button id="exportPDFBtn" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-all flex items-center gap-2">
                            <i class="fas fa-download"></i>
                            Exportar PDF
                        </button>
                    </div>
                </div>
            </div>
        </header>

        <!-- Container da Apresentação -->
        <div id="presentationContainer" class="presentation-container">
            <div class="text-center py-20">
                <div class="animate-spin rounded-full h-12 w-12 border-b-4 border-purple-600 mx-auto mb-4"></div>
                <p class="text-gray-600">Carregando apresentação...</p>
            </div>
        </div>

        <!-- Botão Flutuante Salvar -->
        <div id="saveButtonContainer" class="save-button-container hidden">
            <button id="saveChangesBtn" class="bg-green-600 text-white px-6 py-3 rounded-xl shadow-lg hover:bg-green-700 transition-all flex items-center gap-2 font-semibold">
                <i class="fas fa-save"></i>
                Salvar Alterações
            </button>
        </div>
    </div>

    <script type="module">
        import { auth, db } from './config/firebase.js';
        import { onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
        import { doc, getDoc, updateDoc } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';
        import { presentationsService } from './services/presentationsService.js?v=1.0';

        const urlParams = new URLSearchParams(window.location.search);
        const projectId = urlParams.get('projectId');
        const presentationId = urlParams.get('id');

        let isEditMode = false; // Iniciar em modo visualização
        let hasUnsavedChanges = false;
        let originalHTML = '';
        let customData = {};

        // Elementos DOM
        const presentationContainer = document.getElementById('presentationContainer');
        const saveButtonContainer = document.getElementById('saveButtonContainer');
        const saveChangesBtn = document.getElementById('saveChangesBtn');
        const toggleEditBtn = document.getElementById('toggleEditBtn');
        const exportPDFBtn = document.getElementById('exportPDFBtn');
        const saveBtn = document.getElementById('saveBtn');
        const presentationName = document.getElementById('presentationName');

        // Carregar apresentação
        async function loadPresentation() {
            try {
                const presentation = await presentationsService.getPresentation(projectId, presentationId);
                
                presentationName.textContent = presentation.presentationName || 'Apresentação';
                
                // Carregar customData se existir
                customData = presentation.customData || {};
                
                // Obter HTML original ou usar o salvo
                originalHTML = presentation.presentationHTML || presentation.html || '';
                
                // Renderizar apresentação
                renderPresentation(originalHTML);
                
                // Aguardar renderização para aplicar customizações e ativar edição
                setTimeout(() => {
                // Aplicar customizações
                applyCustomizations();
                
                // Preparar elementos para edição (mas não ativar ainda)
                prepareEditMode();
                
                // Iniciar em modo visualização
                updateEditModeUI();
                
                // Reorganizar cards de anúncios inicialmente
                setTimeout(() => {
                    reorganizeAdCards();
                }, 600);
                }, 1000);
                
            } catch (error) {
                console.error('❌ Erro ao carregar apresentação:', error);
                presentationContainer.innerHTML = `
                    <div class="text-center py-20">
                        <i class="fas fa-exclamation-triangle text-5xl text-red-500 mb-4"></i>
                        <h2 class="text-2xl font-bold text-gray-900 mb-2">Erro ao carregar apresentação</h2>
                        <p class="text-gray-600">${error.message}</p>
                    </div>
                `;
            }
        }

        // Renderizar apresentação
        function renderPresentation(html) {
            presentationContainer.innerHTML = html;
            
            // Extrair todas as imagens Base64 do HTML para customData.adImages em memória
            // Isso permite editar novamente após carregar
            setTimeout(() => {
                const allThumbnails = presentationContainer.querySelectorAll('.ranking-thumbnail[data-ad-image]');
                allThumbnails.forEach(thumbnail => {
                    const adId = thumbnail.getAttribute('data-ad-image');
                    const img = thumbnail.querySelector('img');
                    if (img && img.src && img.src.startsWith('data:image')) {
                        // Se a imagem é Base64 (customizada), extrair para customData em memória
                        if (!customData.adImages) customData.adImages = {};
                        customData.adImages[adId] = img.src;
                        console.log(`✅ Imagem Base64 extraída do HTML para anúncio: ${adId}`);
                    }
                });
            }, 100);
            
            // Aguardar carregamento de fontes e imagens
            document.fonts.ready.then(() => {
                waitForImages().then(() => {
                    console.log('✅ Apresentação renderizada');
                });
            });
        }

        // Aguardar carregamento de imagens
        function waitForImages() {
            const images = Array.from(document.querySelectorAll('img'));
            return Promise.all(
                images.map(img => {
                    if (img.complete) return Promise.resolve();
                    return new Promise(resolve => {
                        img.onload = resolve;
                        img.onerror = resolve;
                    });
                })
            );
        }

        // Aplicar customizações salvas
        function applyCustomizations() {
            if (!customData || Object.keys(customData).length === 0) return;
            
            // Aguardar um pouco para garantir que todos os elementos foram renderizados
            setTimeout(() => {
                // Aplicar customizações de texto
                Object.keys(customData).forEach(editId => {
                    if (editId === 'adImages') return; // Pular objeto de imagens
                    
                    const element = document.querySelector(`[data-edit-id="${editId}"]`);
                    if (element) {
                        const customValue = customData[editId];
                        element.textContent = customValue;
                        element.setAttribute('data-original-value', customValue);
                        console.log(`✅ Aplicada customização para: ${editId} = ${customValue}`);
                    } else {
                        console.warn(`⚠️ Elemento não encontrado: ${editId}`);
                    }
                });
                
                // Aplicar customizações de imagens de anúncios
                // Nota: As imagens já estão no HTML quando carregamos, então só precisamos
                // garantir que as bordas estão removidas e extrair para customData em memória se necessário
                if (customData.adImages && typeof customData.adImages === 'object') {
                    Object.keys(customData.adImages).forEach(adId => {
                        const thumbnail = document.querySelector(`[data-ad-image="${adId}"]`);
                        if (thumbnail) {
                            const img = thumbnail.querySelector('img');
                            if (img) {
                                // Se a imagem é Base64 e ainda não está em customData, extrair para memória
                                if (img.src && img.src.startsWith('data:image')) {
                                    if (!customData.adImages[adId] || customData.adImages[adId] === true) {
                                        customData.adImages[adId] = img.src;
                                        console.log(`✅ Imagem Base64 extraída para customData: ${adId}`);
                                    }
                                }
                                
                                // Remover bordas das imagens customizadas
                                img.style.border = 'none';
                                img.style.outline = 'none';
                                img.style.boxShadow = 'none';
                                img.style.borderRadius = '0';
                                thumbnail.classList.remove('ranking-thumbnail-placeholder');
                                if (thumbnail.parentElement) {
                                    thumbnail.parentElement.classList.remove('ranking-card-placeholder');
                                }
                            }
                        }
                    });
                }
                
                // Extrair TODAS as imagens Base64 do HTML para customData (mesmo as que não estão marcadas em customData.adImages)
                setTimeout(() => {
                    const allThumbnails = document.querySelectorAll('.ranking-thumbnail[data-ad-image]');
                    allThumbnails.forEach(thumbnail => {
                        const adId = thumbnail.getAttribute('data-ad-image');
                        if (adId && adId !== 'placeholder_new') {
                            const img = thumbnail.querySelector('img');
                            if (img && img.src && img.src.startsWith('data:image')) {
                                if (!customData.adImages) customData.adImages = {};
                                customData.adImages[adId] = img.src;
                                console.log(`✅ Imagem Base64 extraída do HTML: ${adId}`);
                            }
                        }
                    });
                }, 200);
                
                // Reorganizar cards após aplicar customizações para garantir placeholder se necessário
                setTimeout(() => {
                    if (typeof reorganizeAdCards === 'function') {
                        reorganizeAdCards();
                    }
                }, 300);
            }, 500);
        }

        // Preparar elementos para edição
        function prepareEditMode() {
            // Encontrar todos os elementos editáveis
            const editables = [
                // Capa
                '.capa-title',
                '.capa-unidade',
                '.capa-periodo',
                
                // Resultados
                '.card-value',
                '.card-label',
                '.resultados-title',
                '.resultados-subtitle',
                
                // Ranking
                '.ranking-title',
                '.ranking-metrics-leads',
                '.ranking-metrics-cost',
                
                // Próximos Passos
                '.proximos-title',
                '.proximos-subtitle',
                '.proximos-list li',
                
                // Obrigado
                '.obrigado-text'
            ];

            editables.forEach(selector => {
                const elements = document.querySelectorAll(selector);
                elements.forEach((element, index) => {
                    // Criar ID único
                    const editId = `${selector.replace(/[.#\s]/g, '_')}_${index}`;
                    element.setAttribute('data-edit-id', editId);
                    element.classList.add('editable');
                    element.setAttribute('data-editable', 'true');
                    
                    // Event listeners
                    element.addEventListener('click', () => {
                        if (isEditMode && !element.hasAttribute('contenteditable')) {
                            startEditing(element, editId);
                        }
                    });
                    
                    element.addEventListener('blur', () => {
                        stopEditing(element, editId);
                    });
                });
            });
            
            // Adicionar métricas de anúncios como editáveis
            setTimeout(() => {
                const adMetrics = document.querySelectorAll('[data-ad-leads], [data-ad-cost]');
                adMetrics.forEach((element) => {
                    const adId = element.getAttribute('data-ad-leads') || element.getAttribute('data-ad-cost');
                    const metricType = element.classList.contains('ranking-metrics-leads') ? 'leads' : 'cost';
                    const editId = `ad_${adId}_${metricType}`;
                    
                    element.setAttribute('data-edit-id', editId);
                    element.classList.add('editable');
                    
                    element.addEventListener('click', () => {
                        if (isEditMode && !element.hasAttribute('contenteditable')) {
                            startEditing(element, editId);
                        }
                    });
                    
                    element.addEventListener('blur', () => {
                        stopEditing(element, editId);
                    });
                });
            }, 100);
            
            // Atualizar UI baseado no modo
            updateEditModeUI();
            setupAdImageEditing();
        }
        
        // Atualizar UI baseado no modo
        function updateEditModeUI() {
            const editables = document.querySelectorAll('.editable');
            editables.forEach(el => {
                if (isEditMode) {
                    el.style.cursor = 'text';
                } else {
                    el.style.cursor = 'default';
                    el.removeAttribute('contenteditable');
                }
            });
            
            // Mostrar/ocultar botões de deletar anúncios (não mostrar no placeholder)
            const deleteButtons = document.querySelectorAll('.ranking-card-delete');
            deleteButtons.forEach(btn => {
                const card = btn.closest('.ranking-card');
                // Não mostrar botão de deletar no placeholder
                if (card && card.classList.contains('ranking-card-placeholder')) {
                    btn.style.display = 'none';
                } else {
                    btn.style.display = isEditMode ? 'flex' : 'none';
                }
            });
        }
        
        // Configurar edição de imagens dos anúncios
        function setupAdImageEditing() {
            const thumbnails = document.querySelectorAll('.ranking-thumbnail-editable');
            
            thumbnails.forEach(thumbnail => {
                const adId = thumbnail.getAttribute('data-ad-image');
                if (!adId) return;
                
                const fileInput = document.querySelector(`[data-ad-input="${adId}"]`);
                if (!fileInput) return;
                
                // Remover listeners antigos clonando o elemento
                const newThumbnail = thumbnail.cloneNode(true);
                thumbnail.parentNode.replaceChild(newThumbnail, thumbnail);
                
                // Remover listeners antigos do file input clonando
                const newFileInput = fileInput.cloneNode(true);
                fileInput.parentNode.replaceChild(newFileInput, fileInput);
                
                // Click para selecionar arquivo
                newThumbnail.addEventListener('click', (e) => {
                    if (isEditMode && !e.target.closest('.ranking-card-delete')) {
                        newFileInput.click();
                    }
                });
                
                // Drag & Drop
                newThumbnail.addEventListener('dragover', (e) => {
                    if (isEditMode) {
                        e.preventDefault();
                        newThumbnail.style.border = '2px solid #9333EA';
                        newThumbnail.style.backgroundColor = 'rgba(147, 51, 234, 0.1)';
                    }
                });
                
                newThumbnail.addEventListener('dragleave', () => {
                    newThumbnail.style.border = '';
                    newThumbnail.style.backgroundColor = '';
                });
                
                newThumbnail.addEventListener('drop', (e) => {
                    if (isEditMode) {
                        e.preventDefault();
                        newThumbnail.style.border = '';
                        newThumbnail.style.backgroundColor = '';
                        
                        const files = e.dataTransfer.files;
                        if (files.length > 0 && files[0].type.startsWith('image/')) {
                            handleImageUpload(files[0], adId, newThumbnail, newFileInput);
                        }
                    }
                });
                
                // File input change
                newFileInput.addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        handleImageUpload(e.target.files[0], adId, newThumbnail, newFileInput);
                        // Limpar o valor para permitir selecionar o mesmo arquivo novamente
                        e.target.value = '';
                    }
                });
            });
            
            // Configurar botões de deletar
            setupDeleteButtons();
        }
        
        // Processar upload de imagem
        function handleImageUpload(file, adId, thumbnail, fileInput) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const imageUrl = e.target.result; // Base64
                
                // Atualizar imagem
                const existingImg = thumbnail.querySelector('img');
                if (existingImg) {
                    existingImg.src = imageUrl;
                    // Remover qualquer borda ou outline das imagens customizadas
                    existingImg.style.border = 'none';
                    existingImg.style.outline = 'none';
                    existingImg.style.boxShadow = 'none';
                    existingImg.style.borderRadius = '0';
                } else {
                    // Se não tem img, criar uma
                    const placeholder = thumbnail.querySelector('div');
                    if (placeholder) {
                        thumbnail.innerHTML = `<img src="${imageUrl}" alt="Anúncio" style="width:100%;height:100%;object-fit:cover;border:none;outline:none;box-shadow:none;border-radius:0;">`;
                    } else {
                        // Se não tem nada, criar img diretamente
                        thumbnail.innerHTML = `<img src="${imageUrl}" alt="Anúncio" style="width:100%;height:100%;object-fit:cover;border:none;outline:none;box-shadow:none;border-radius:0;">`;
                    }
                }
                
                // Remover placeholder class se existir
                thumbnail.classList.remove('ranking-thumbnail-placeholder');
                const card = thumbnail.closest('.ranking-card');
                if (card) {
                    card.classList.remove('ranking-card-placeholder');
                    
                    // Garantir que o botão de deletar existe e está visível (se em modo edição)
                    if (isEditMode) {
                        let deleteBtn = card.querySelector('.ranking-card-delete');
                        if (!deleteBtn) {
                            // Criar botão de deletar se não existir
                            deleteBtn = document.createElement('button');
                            deleteBtn.className = 'ranking-card-delete';
                            deleteBtn.style.cssText = 'position:absolute;top:10px;right:10px;z-index:10;width:32px;height:32px;background:rgba(239,68,68,0.9);border:none;border-radius:50%;color:white;cursor:pointer;display:flex;align-items:center;justify-content:center;';
                            deleteBtn.innerHTML = '<i class="fas fa-trash" style="font-size:14px;"></i>';
                            deleteBtn.title = 'Remover anúncio';
                            card.style.position = 'relative';
                            card.appendChild(deleteBtn);
                        }
                        // Mostrar botão de deletar
                        deleteBtn.style.display = 'flex';
                    }
                }
                
                // Salvar no customData
                if (!customData.adImages) customData.adImages = {};
                customData.adImages[adId] = imageUrl;
                
                // Se for placeholder_new, criar novo ID
                if (adId === 'placeholder_new') {
                    const newAdId = `ad_custom_${Date.now()}`;
                    thumbnail.setAttribute('data-ad-image', newAdId);
                    
                    // Verificar se o img existe antes de atualizar
                    const img = thumbnail.querySelector('img');
                    if (img) {
                        img.setAttribute('data-ad-image', newAdId);
                    }
                    
                    customData.adImages[newAdId] = imageUrl;
                    delete customData.adImages[adId];
                    
                    // Atualizar outros atributos
                    if (card) {
                        card.setAttribute('data-ad-id', newAdId);
                        
                        const leadsElement = card.querySelector('[data-ad-leads]');
                        if (leadsElement) {
                            leadsElement.setAttribute('data-ad-leads', newAdId);
                        }
                        
                        const costElement = card.querySelector('[data-ad-cost]');
                        if (costElement) {
                            costElement.setAttribute('data-ad-cost', newAdId);
                        }
                    }
                    
                    if (fileInput) {
                        fileInput.setAttribute('data-ad-input', newAdId);
                    }
                }
                
                // Reconfigurar botões de deletar após adicionar imagem
                setTimeout(() => {
                    setupDeleteButtons();
                }, 100);
                
                markAsChanged();
            };
            reader.readAsDataURL(file);
        }
        
        // Configurar botões de deletar
        function setupDeleteButtons() {
            const deleteButtons = document.querySelectorAll('.ranking-card-delete');
            deleteButtons.forEach(btn => {
                // Não adicionar listener no placeholder
                const card = btn.closest('.ranking-card');
                if (card && card.classList.contains('ranking-card-placeholder')) {
                    return; // Não adicionar listener em placeholder
                }
                
                // Remover listeners antigos clonando o botão
                const newBtn = btn.cloneNode(true);
                btn.parentNode.replaceChild(newBtn, btn);
                
                newBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    const currentCard = newBtn.closest('.ranking-card');
                    if (isEditMode && currentCard && !currentCard.classList.contains('ranking-card-placeholder')) {
                        if (confirm('Tem certeza que deseja remover este anúncio?')) {
                            deleteAdCard(currentCard);
                        }
                    }
                });
            });
        }
        
        // Deletar card de anúncio
        function deleteAdCard(card) {
            const adId = card.getAttribute('data-ad-id');
            
            // SEMPRE marcar como mudado ANTES de qualquer operação
            markAsChanged();
            
            // Remover do customData
            if (customData.adImages && customData.adImages[adId]) {
                delete customData.adImages[adId];
            }
            
            // Remover card
            card.remove();
            
            // Reorganizar cards e mostrar placeholder se necessário
            reorganizeAdCards();
        }
        
        // Reorganizar cards após deletar
        function reorganizeAdCards() {
            const grid = document.querySelector('.ranking-grid');
            if (!grid) return;
            
            const cards = Array.from(grid.querySelectorAll('.ranking-card:not(.ranking-card-placeholder)'));
            const placeholder = grid.querySelector('.ranking-card-placeholder');
            
            // Sempre manter 3 colunas para layout consistente
            grid.style.gridTemplateColumns = 'repeat(3, 1fr)';
            // Garantir que os cards mantenham o mesmo tamanho
            grid.style.gridAutoRows = 'auto';
            
            // Se tem menos de 3 cards, garantir que placeholder existe e está visível
            if (cards.length < 3) {
                if (!placeholder) {
                    // Criar placeholder se não existir
                    const placeholderHTML = `
                    <div class="ranking-card ranking-card-placeholder" data-ad-id="placeholder_new" style="display:flex;">
                        <div class="ranking-thumbnail ranking-thumbnail-editable ranking-thumbnail-placeholder" data-ad-image="placeholder_new" style="border:2px dashed #9333EA;background:#f9fafb;cursor:pointer;display:flex;align-items:center;justify-content:center;flex-direction:column;color:#9333EA;">
                            <i class="fas fa-plus-circle" style="font-size:48px;margin-bottom:8px;"></i>
                            <span style="font-size:14px;font-weight:500;">Clique ou arraste uma imagem</span>
                        </div>
                        <div class="ranking-metrics-bar">
                            <span class="ranking-metrics-leads" data-ad-leads="placeholder_new">0 Leads</span>
                            <span class="ranking-metrics-cost" data-ad-cost="placeholder_new">R$ 0,00</span>
                        </div>
                        <input type="file" accept="image/*" class="ranking-image-input" data-ad-input="placeholder_new" style="display:none;">
                    </div>
                    `;
                    grid.insertAdjacentHTML('beforeend', placeholderHTML);
                    // Reconfigurar edição de imagens após criar placeholder
                    if (isEditMode) {
                        setTimeout(() => {
                            setupAdImageEditing();
                        }, 100);
                    }
                } else {
                    placeholder.style.display = 'flex';
                    // Esconder botão de deletar do placeholder
                    const placeholderDeleteBtn = placeholder.querySelector('.ranking-card-delete');
                    if (placeholderDeleteBtn) {
                        placeholderDeleteBtn.style.display = 'none';
                    }
                }
            } else if (placeholder) {
                placeholder.style.display = 'none';
            }
            
            // Centralizar grid sem alterar tamanho dos cards
            if (cards.length === 1) {
                // Usar justify-content no grid container sem alterar o tamanho dos cards
                grid.style.justifyContent = 'center';
                grid.style.justifyItems = 'stretch';
            } else if (cards.length === 2) {
                grid.style.justifyContent = 'center';
                grid.style.justifyItems = 'stretch';
            } else {
                grid.style.justifyContent = '';
                grid.style.justifyItems = 'stretch';
            }
            
            // Reconfigurar edição de imagens após reorganizar
            if (isEditMode) {
                setTimeout(() => {
                    setupAdImageEditing();
                }, 100);
            }
        }

        // Iniciar edição
        function startEditing(element, editId) {
            element.setAttribute('contenteditable', 'true');
            element.focus();
            
            // Selecionar texto
            const range = document.createRange();
            range.selectNodeContents(element);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
        }

        // Parar edição
        function stopEditing(element, editId) {
            element.removeAttribute('contenteditable');
            
            // Salvar alteração
            const newValue = element.textContent.trim();
            
            // Obter valor original (da primeira renderização ou do customData)
            if (!element.hasAttribute('data-original-value')) {
                // Primeira vez editando - salvar valor original
                const originalText = element.textContent.trim();
                element.setAttribute('data-original-value', originalText);
            }
            
            const originalValue = element.getAttribute('data-original-value') || '';
            
            // Detectar qualquer alteração (adicionar, remover, modificar - mesmo que fique vazio)
            if (newValue !== originalValue) {
                // SEMPRE marcar como mudado ANTES de restaurar qualquer valor visual
                markAsChanged();
                
                if (newValue === '') {
                    // Se ficou vazio, remover do customData mas manter a mudança registrada
                    delete customData[editId];
                    // Restaurar valor original visualmente
                    element.textContent = originalValue;
                    element.setAttribute('data-original-value', originalValue);
                } else {
                    customData[editId] = newValue;
                }
                console.log(`💾 Alteração detectada: ${editId} (original: "${originalValue}" -> novo: "${newValue}")`);
            }
        }

        // Marcar como alterado
        function markAsChanged() {
            hasUnsavedChanges = true;
            saveButtonContainer.classList.remove('hidden');
            saveBtn.classList.remove('hidden');
            console.log('✅ Botão salvar habilitado');
        }

        // Salvar alterações
        async function saveChanges() {
            if (!hasUnsavedChanges) {
                alert('Nenhuma alteração para salvar');
                return;
            }

            saveChangesBtn.disabled = true;
            saveChangesBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Salvando...';

            try {
                // Aplicar customizações de imagens no HTML antes de salvar
                applyImageCustomizationsToHTML();
                
                // Limpar HTML antes de salvar (remover elementos de edição e otimizar)
                const cleanedHTML = await cleanHTMLForSave(presentationContainer.innerHTML);
                
                // Preparar customData para salvar (remover imagens Base64 grandes)
                const customDataToSave = { ...customData };
                
                // Remover imagens Base64 de customData.adImages (elas já estão no HTML)
                // Manter apenas referência de quais anúncios foram customizados
                if (customDataToSave.adImages) {
                    const adImagesReference = {};
                    // Guardar apenas IDs dos anúncios customizados, sem as imagens Base64
                    Object.keys(customDataToSave.adImages).forEach(adId => {
                        adImagesReference[adId] = true; // Apenas marcação, não a imagem
                    });
                    customDataToSave.adImages = adImagesReference;
                }
                
                await presentationsService.updatePresentation(projectId, presentationId, {
                    customData: customDataToSave,
                    html: cleanedHTML,
                    updatedAt: new Date().toISOString()
                });

                hasUnsavedChanges = false;
                saveButtonContainer.classList.add('hidden');
                saveBtn.classList.add('hidden');
                saveChangesBtn.disabled = false;
                saveChangesBtn.innerHTML = '<i class="fas fa-save"></i> Salvar Alterações';

                // Mostrar feedback
                showNotification('Alterações salvas com sucesso!', 'success');

            } catch (error) {
                console.error('❌ Erro ao salvar:', error);
                saveChangesBtn.disabled = false;
                saveChangesBtn.innerHTML = '<i class="fas fa-save"></i> Salvar Alterações';
                showNotification('Erro ao salvar alterações', 'error');
            }
        }

        // Mostrar notificação
        function showNotification(message, type = 'success') {
            const notification = document.createElement('div');
            notification.className = `fixed top-4 right-4 px-6 py-3 rounded-lg shadow-lg z-50 ${
                type === 'success' ? 'bg-green-600 text-white' : 'bg-red-600 text-white'
            }`;
            notification.innerHTML = `
                <div class="flex items-center gap-2">
                    <i class="fas ${type === 'success' ? 'fa-check-circle' : 'fa-exclamation-circle'}"></i>
                    <span>${message}</span>
                </div>
            `;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.style.opacity = '0';
                notification.style.transition = 'opacity 0.3s';
                setTimeout(() => notification.remove(), 300);
            }, 3000);
        }

        // Toggle modo de edição
        toggleEditBtn.addEventListener('click', () => {
            isEditMode = !isEditMode;
            updateEditModeUI();
            
            // Reconfigurar edição de imagens quando mudar modo
            if (isEditMode) {
                setupAdImageEditing();
            }
            
            toggleEditBtn.innerHTML = isEditMode 
                ? '<i class="fas fa-eye"></i> Modo Visualização'
                : '<i class="fas fa-edit"></i> Modo Edição';
        });

        // Salvar alterações
        saveChangesBtn.addEventListener('click', saveChanges);
        saveBtn.addEventListener('click', saveChanges);

        // Exportar PDF
        exportPDFBtn.addEventListener('click', () => {
            // Aplicar customizações de imagens antes de exportar
            applyImageCustomizationsToHTML();
            
            // Remover classes e atributos de edição
            const editables = document.querySelectorAll('.editable');
            editables.forEach(el => {
                el.classList.remove('editable');
                el.removeAttribute('data-editable');
                el.removeAttribute('data-edit-id');
                el.removeAttribute('contenteditable');
                el.style.cursor = '';
                el.style.outline = '';
                el.style.backgroundColor = '';
            });
            
            // Remover botões de deletar e inputs de arquivo
            document.querySelectorAll('.ranking-card-delete').forEach(btn => btn.remove());
            document.querySelectorAll('.ranking-image-input').forEach(input => input.remove());
            
            // Remover placeholder se existir
            const placeholder = document.querySelector('.ranking-card-placeholder');
            if (placeholder) placeholder.remove();
            
            // Obter HTML limpo (sem elementos de edição)
            const cleanHTML = presentationContainer.innerHTML;
            
            // Restaurar elementos para edição (caso o usuário queira editar depois)
            setTimeout(() => {
                prepareEditMode();
            }, 100);
            
            // Salvar em sessionStorage para o apresentacao-print.html usar
            sessionStorage.setItem('presentationPrintPayload', JSON.stringify({
                html: cleanHTML
            }));
            
            // Abrir página de impressão
            window.open(`apresentacao-print.html?mode=session&auto=1`, '_blank');
        });
        
        // Aplicar customizações de imagens ao HTML antes de salvar
        function applyImageCustomizationsToHTML() {
            if (!customData.adImages) return;
            
            Object.keys(customData.adImages).forEach(adId => {
                const thumbnail = document.querySelector(`[data-ad-image="${adId}"]`);
                if (thumbnail) {
                    const img = thumbnail.querySelector('img');
                    if (img && customData.adImages[adId]) {
                        img.src = customData.adImages[adId];
                        // Remover bordas das imagens customizadas
                        img.style.border = 'none';
                        img.style.outline = 'none';
                        img.style.boxShadow = 'none';
                        img.style.borderRadius = '0';
                    }
                }
            });
        }
        
        // Comprimir imagem Base64 reduzindo qualidade
        async function compressBase64Image(base64String, maxWidth = 800, quality = 0.7) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    let width = img.width;
                    let height = img.height;
                    
                    // Redimensionar se necessário
                    if (width > maxWidth) {
                        height = (height * maxWidth) / width;
                        width = maxWidth;
                    }
                    
                    canvas.width = width;
                    canvas.height = height;
                    
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, width, height);
                    
                    // Converter para JPEG com qualidade reduzida
                    const compressed = canvas.toDataURL('image/jpeg', quality);
                    resolve(compressed);
                };
                img.onerror = () => resolve(base64String); // Se falhar, retorna original
                img.src = base64String;
            });
        }
        
        // Limpar e otimizar HTML antes de salvar para reduzir tamanho
        async function cleanHTMLForSave(html) {
            // Criar um elemento temporário para manipular o HTML
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = html;
            
            // Remover elementos de edição desnecessários
            tempDiv.querySelectorAll('.ranking-card-delete').forEach(el => el.remove());
            tempDiv.querySelectorAll('.ranking-image-input').forEach(el => el.remove());
            tempDiv.querySelectorAll('.ranking-card-placeholder').forEach(el => el.remove());
            tempDiv.querySelectorAll('[contenteditable]').forEach(el => el.removeAttribute('contenteditable'));
            tempDiv.querySelectorAll('[data-edit-id]').forEach(el => el.removeAttribute('data-edit-id'));
            tempDiv.querySelectorAll('.editable').forEach(el => el.classList.remove('editable'));
            
            // Comprimir imagens Base64 se necessário
            const images = tempDiv.querySelectorAll('.ranking-thumbnail img');
            for (const img of images) {
                const src = img.getAttribute('src');
                if (src && src.startsWith('data:image')) {
                    // Comprimir imagem Base64 para reduzir tamanho
                    const compressed = await compressBase64Image(src, 800, 0.75);
                    img.setAttribute('src', compressed);
                }
            }
            
            // Minificar HTML removendo espaços extras
            let cleaned = tempDiv.innerHTML;
            
            // Remover múltiplos espaços em branco e quebras de linha extras
            cleaned = cleaned.replace(/>\s+</g, '><');
            cleaned = cleaned.replace(/\s+/g, ' ');
            
            // Verificar tamanho do HTML
            const htmlSize = new Blob([cleaned]).size;
            console.log(`📊 Tamanho do HTML após limpeza: ${(htmlSize / 1024).toFixed(2)} KB`);
            
            // Se ainda estiver muito grande (>950KB), comprimir mais agressivamente
            if (htmlSize > 950 * 1024) {
                console.warn('⚠️ HTML ainda muito grande, comprimindo imagens mais agressivamente...');
                const tempDiv2 = document.createElement('div');
                tempDiv2.innerHTML = cleaned;
                const images2 = tempDiv2.querySelectorAll('.ranking-thumbnail img');
                for (const img of images2) {
                    const src = img.getAttribute('src');
                    if (src && src.startsWith('data:image')) {
                        const compressed = await compressBase64Image(src, 600, 0.6);
                        img.setAttribute('src', compressed);
                    }
                }
                cleaned = tempDiv2.innerHTML;
                cleaned = cleaned.replace(/>\s+</g, '><');
                cleaned = cleaned.replace(/\s+/g, ' ');
                const finalSize = new Blob([cleaned]).size;
                console.log(`📊 Tamanho final do HTML: ${(finalSize / 1024).toFixed(2)} KB`);
            }
            
            return cleaned;
        }

        // Carregar quando autenticado
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                await loadPresentation();
            } else {
                window.location.href = '/login.html';
            }
        });
    </script>
    <script type="module">
        import { initSidebar } from './components/sidebar.js';
        initSidebar();
    </script>
</body>
</html>

