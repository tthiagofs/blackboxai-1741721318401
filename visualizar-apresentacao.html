<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualizar Apresenta√ß√£o - Insightflow</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="style.css">
    <style>
        /* Estilos para edi√ß√£o inline */
        .editable {
            position: relative;
            transition: all 0.2s;
        }
        
        .editable:hover {
            background-color: rgba(147, 51, 234, 0.1);
            outline: 2px dashed rgba(147, 51, 234, 0.3);
            outline-offset: 2px;
            cursor: text;
        }
        
        .editable[contenteditable="true"] {
            background-color: rgba(147, 51, 234, 0.15);
            outline: 2px solid rgba(147, 51, 234, 0.5);
            outline-offset: 2px;
        }
        
        .editable[contenteditable="true"]:focus {
            outline: 2px solid rgba(147, 51, 234, 0.8);
            background-color: rgba(147, 51, 234, 0.2);
        }
        
        /* Bot√£o flutuante de salvar */
        .save-button-container {
            position: fixed;
            bottom: 30px;
            right: 30px;
            z-index: 1000;
            animation: slideUp 0.3s ease-out;
        }
        
        @keyframes slideUp {
            from {
                transform: translateY(100px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        /* Preview container */
        .presentation-container {
            background: #f0f0f0;
            padding: 40px 20px;
            min-height: 100vh;
        }
        
        .presentation-container .page {
            margin: 20px auto;
        }
        
        /* Modo Apresenta√ß√£o */
        .presentation-mode {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            z-index: 9999;
            overflow: hidden;
            display: none;
        }
        
        .presentation-mode.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .presentation-mode .slide-container {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        
        /* Modo apresenta√ß√£o - replicar EXATAMENTE a l√≥gica do apresentacao-print.html */
        .presentation-mode {
            background: #000;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 9999;
            overflow: hidden;
            display: none;
            /* Centralizar conte√∫do */
            align-items: center;
            justify-content: center;
        }
        
        .presentation-mode.active {
            display: flex;
        }
        
        .presentation-mode #presentationSlides {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        
        /* Cada slide - manter tamanho original (igual √† visualiza√ß√£o normal) */
        .presentation-mode .slide {
            display: none;
            /* Tamanho FIXO original - N√ÉO alterar (igual √† tela de visualiza√ß√£o) */
            width: 1280px;
            height: 720px;
            /* Centralizar usando flexbox do container */
            margin: 0;
            position: relative;
            overflow: hidden; /* hidden para n√£o mostrar conte√∫do que ultrapasse */
            background: white;
            padding: 0;
            /* Scale ser√° aplicado via JavaScript, mantendo propor√ß√µes */
            transform-origin: center center;
            /* Garantir que o conte√∫do interno seja renderizado corretamente */
            box-sizing: border-box;
            /* Prevenir distor√ß√£o */
            will-change: transform;
            backface-visibility: hidden;
        }
        
        /* Slide ativo √© vis√≠vel */
        .presentation-mode .slide.active {
            display: block;
        }
        
        /* IMPORTANTE: N√ÉO sobrescrever estilos da classe .page */
        /* Os estilos j√° v√™m do style.css e do gerar-html-apresentacao.js */
        /* A classe .page j√° tem width: 1280px e height: 720px definidos */
        .presentation-mode .slide.page {
            /* N√ÉO for√ßar width/height 100% - deixar os estilos originais */
            /* Os estilos originais j√° definem o tamanho correto */
        }
        
        /* Garantir que elementos internos mantenham propor√ß√µes */
        .presentation-mode .slide * {
            box-sizing: border-box;
        }
        
        /* Remover bordas de imagens (igual ao print) */
        .presentation-mode .ranking-thumbnail,
        .presentation-mode .ranking-thumbnail img,
        .presentation-mode .ranking-thumbnail * {
            border: none !important;
            outline: none !important;
            box-shadow: none !important;
            border-radius: 0 !important;
        }
        
        .presentation-mode .ranking-card {
            border: none !important;
            outline: none !important;
        }
        
        .presentation-controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            padding: 10px 20px;
            border-radius: 50px;
            display: flex;
            align-items: center;
            gap: 15px;
            z-index: 10000;
            color: white;
            font-size: 14px;
        }
        
        .presentation-controls button {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            padding: 8px 12px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .presentation-controls button:hover {
            background: rgba(255,255,255,0.3);
        }
        
        .presentation-controls button:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        .presentation-exit {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            border: none;
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            z-index: 10001;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .presentation-exit:hover {
            background: rgba(0,0,0,0.9);
        }
        
        .presentation-slide-indicator {
            font-weight: 600;
            min-width: 80px;
            text-align: center;
        }
    </style>
</head>
<body class="bg-gray-50 font-sans">
    <div class="min-h-screen">
        <!-- Header -->
        <header class="bg-white border-b border-gray-200 shadow-sm">
            <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4">
                <div class="flex items-center justify-between">
                    <div class="flex items-center gap-4">
                        <button onclick="window.history.back()" class="p-2 hover:bg-gray-100 rounded-lg transition-colors">
                            <i class="fas fa-arrow-left text-gray-700"></i>
                        </button>
                        <div>
                            <h1 id="presentationName" class="text-xl font-bold text-gray-900">Carregando...</h1>
                            <p class="text-sm text-gray-600">Ative o modo edi√ß√£o para personalizar os dados</p>
                        </div>
                    </div>
                    <div class="flex items-center gap-3">
                        <button id="toggleEditBtn" class="px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition-all flex items-center gap-2">
                            <i class="fas fa-edit"></i>
                            Modo Edi√ß√£o
                        </button>
                        <button id="saveBtn" class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-all flex items-center gap-2 hidden">
                            <i class="fas fa-save"></i>
                            Salvar
                        </button>
                        <button id="presentBtn" class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-all flex items-center gap-2">
                            <i class="fas fa-presentation"></i>
                            Apresentar
                        </button>
                        <button id="exportPDFBtn" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-all flex items-center gap-2">
                            <i class="fas fa-download"></i>
                            Exportar PDF
                        </button>
                    </div>
                </div>
            </div>
        </header>

        <!-- Container da Apresenta√ß√£o -->
        <div id="presentationContainer" class="presentation-container">
            <div class="text-center py-20">
                <div class="animate-spin rounded-full h-12 w-12 border-b-4 border-purple-600 mx-auto mb-4"></div>
                <p class="text-gray-600">Carregando apresenta√ß√£o...</p>
            </div>
        </div>

        <!-- Bot√£o Flutuante Salvar -->
        <div id="saveButtonContainer" class="save-button-container hidden">
            <button id="saveChangesBtn" class="bg-green-600 text-white px-6 py-3 rounded-xl shadow-lg hover:bg-green-700 transition-all flex items-center gap-2 font-semibold">
                <i class="fas fa-save"></i>
                Salvar Altera√ß√µes
            </button>
        </div>
        
        <!-- Modo Apresenta√ß√£o -->
        <div id="presentationMode" class="presentation-mode">
            <button id="exitPresentationBtn" class="presentation-exit">
                <i class="fas fa-times"></i>
                Sair (ESC)
            </button>
            <div class="slide-container">
                <div id="presentationSlides"></div>
            </div>
            <div class="presentation-controls">
                <button id="prevSlideBtn" title="Anterior (‚Üë ou ‚Üê)">
                    <i class="fas fa-chevron-left"></i>
                </button>
                <span class="presentation-slide-indicator">
                    <span id="currentSlideNumber">1</span> / <span id="totalSlides">1</span>
                </span>
                <button id="nextSlideBtn" title="Pr√≥ximo (‚Üì ou ‚Üí)">
                    <i class="fas fa-chevron-right"></i>
                </button>
            </div>
        </div>
    </div>

    <script type="module">
        import { auth, db } from './config/firebase.js';
        import { onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
        import { doc, getDoc, updateDoc } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';
        import { presentationsService } from './services/presentationsService.js?v=1.0';

        const urlParams = new URLSearchParams(window.location.search);
        const projectId = urlParams.get('projectId');
        const presentationId = urlParams.get('id');

        let isEditMode = false; // Iniciar em modo visualiza√ß√£o
        let hasUnsavedChanges = false;
        let originalHTML = '';
        let customData = {};

        // Elementos DOM
        const presentationContainer = document.getElementById('presentationContainer');
        const saveButtonContainer = document.getElementById('saveButtonContainer');
        const saveChangesBtn = document.getElementById('saveChangesBtn');
        const toggleEditBtn = document.getElementById('toggleEditBtn');
        const exportPDFBtn = document.getElementById('exportPDFBtn');
        const presentBtn = document.getElementById('presentBtn');
        const saveBtn = document.getElementById('saveBtn');
        const presentationName = document.getElementById('presentationName');
        
        // Vari√°veis do modo apresenta√ß√£o
        let isPresentationMode = false;
        let currentSlideIndex = 0;
        let slides = [];

        // Carregar apresenta√ß√£o
        async function loadPresentation() {
            try {
                const presentation = await presentationsService.getPresentation(projectId, presentationId);
                
                presentationName.textContent = presentation.presentationName || 'Apresenta√ß√£o';
                
                // Carregar customData se existir
                customData = presentation.customData || {};
                
                // Obter HTML original ou usar o salvo
                originalHTML = presentation.presentationHTML || presentation.html || '';
                
                // Renderizar apresenta√ß√£o
                renderPresentation(originalHTML);
                
                // Aguardar renderiza√ß√£o para aplicar customiza√ß√µes e ativar edi√ß√£o
                setTimeout(() => {
                // Aplicar customiza√ß√µes
                applyCustomizations();
                
                // Preparar elementos para edi√ß√£o (mas n√£o ativar ainda)
                prepareEditMode();
                
                // Iniciar em modo visualiza√ß√£o
                updateEditModeUI();
                
                // Reorganizar cards de an√∫ncios inicialmente
                setTimeout(() => {
                    reorganizeAdCards();
                }, 600);
                }, 1000);
                
            } catch (error) {
                console.error('‚ùå Erro ao carregar apresenta√ß√£o:', error);
                presentationContainer.innerHTML = `
                    <div class="text-center py-20">
                        <i class="fas fa-exclamation-triangle text-5xl text-red-500 mb-4"></i>
                        <h2 class="text-2xl font-bold text-gray-900 mb-2">Erro ao carregar apresenta√ß√£o</h2>
                        <p class="text-gray-600">${error.message}</p>
                    </div>
                `;
            }
        }

        // Renderizar apresenta√ß√£o
        function renderPresentation(html) {
            presentationContainer.innerHTML = html;
            
            // Extrair todas as imagens Base64 do HTML para customData.adImages em mem√≥ria
            // Isso permite editar novamente ap√≥s carregar
            setTimeout(() => {
                const allThumbnails = presentationContainer.querySelectorAll('.ranking-thumbnail[data-ad-image]');
                allThumbnails.forEach(thumbnail => {
                    const adId = thumbnail.getAttribute('data-ad-image');
                    if (adId && adId !== 'placeholder_new') {
                        const img = thumbnail.querySelector('img');
                        if (img && img.src && img.src.startsWith('data:image')) {
                            // Se a imagem √© Base64 (customizada), extrair para customData em mem√≥ria
                            if (!customData.adImages) customData.adImages = {};
                            customData.adImages[adId] = img.src;
                            console.log(`‚úÖ Imagem Base64 extra√≠da do HTML para an√∫ncio: ${adId}`);
                        }
                        
                        // Garantir que file input existe para este an√∫ncio
                        let fileInput = document.querySelector(`[data-ad-input="${adId}"]`);
                        if (!fileInput) {
                            const card = thumbnail.closest('.ranking-card');
                            if (card) {
                                fileInput = document.createElement('input');
                                fileInput.type = 'file';
                                fileInput.accept = 'image/*';
                                fileInput.className = 'ranking-image-input';
                                fileInput.setAttribute('data-ad-input', adId);
                                fileInput.style.display = 'none';
                                card.appendChild(fileInput);
                                console.log(`‚úÖ File input criado para: ${adId}`);
                            }
                        }
                    }
                });
            }, 200);
            
            // Aguardar carregamento de fontes e imagens
            document.fonts.ready.then(() => {
                waitForImages().then(() => {
                    console.log('‚úÖ Apresenta√ß√£o renderizada');
                });
            });
        }

        // Aguardar carregamento de imagens (usado tanto na renderiza√ß√£o normal quanto no modo apresenta√ß√£o)
        function waitForImages(selector = 'img') {
            const images = Array.from(document.querySelectorAll(selector));
            return Promise.all(
                images.map(img => {
                    if (img.complete) return Promise.resolve();
                    return new Promise(resolve => {
                        img.onload = resolve;
                        img.onerror = resolve; // Continuar mesmo se imagem falhar
                    });
                })
            );
        }

        // Aplicar customiza√ß√µes salvas
        function applyCustomizations() {
            if (!customData || Object.keys(customData).length === 0) return;
            
            // Aguardar um pouco para garantir que todos os elementos foram renderizados
            setTimeout(() => {
                // Aplicar customiza√ß√µes de texto
                Object.keys(customData).forEach(editId => {
                    if (editId === 'adImages') return; // Pular objeto de imagens
                    
                    const element = document.querySelector(`[data-edit-id="${editId}"]`);
                    if (element) {
                        const customValue = customData[editId];
                        element.textContent = customValue;
                        element.setAttribute('data-original-value', customValue);
                        console.log(`‚úÖ Aplicada customiza√ß√£o para: ${editId} = ${customValue}`);
                    } else {
                        console.warn(`‚ö†Ô∏è Elemento n√£o encontrado: ${editId}`);
                    }
                });
                
                // Aplicar customiza√ß√µes de imagens de an√∫ncios
                // Nota: As imagens j√° est√£o no HTML quando carregamos, ent√£o s√≥ precisamos
                // garantir que as bordas est√£o removidas e extrair para customData em mem√≥ria se necess√°rio
                if (customData.adImages && typeof customData.adImages === 'object') {
                    Object.keys(customData.adImages).forEach(adId => {
                        const thumbnail = document.querySelector(`[data-ad-image="${adId}"]`);
                        if (thumbnail) {
                            const img = thumbnail.querySelector('img');
                            if (img) {
                                // Se a imagem √© Base64 e ainda n√£o est√° em customData, extrair para mem√≥ria
                                if (img.src && img.src.startsWith('data:image')) {
                                    if (!customData.adImages[adId] || customData.adImages[adId] === true) {
                                        customData.adImages[adId] = img.src;
                                        console.log(`‚úÖ Imagem Base64 extra√≠da para customData: ${adId}`);
                                    }
                                }
                                
                                // Remover bordas das imagens customizadas
                                img.style.border = 'none';
                                img.style.outline = 'none';
                                img.style.boxShadow = 'none';
                                img.style.borderRadius = '0';
                                thumbnail.classList.remove('ranking-thumbnail-placeholder');
                                if (thumbnail.parentElement) {
                                    thumbnail.parentElement.classList.remove('ranking-card-placeholder');
                                }
                            }
                        }
                    });
                }
                
                // Extrair TODAS as imagens Base64 do HTML para customData (mesmo as que n√£o est√£o marcadas em customData.adImages)
                setTimeout(() => {
                    const allThumbnails = document.querySelectorAll('.ranking-thumbnail[data-ad-image]');
                    allThumbnails.forEach(thumbnail => {
                        const adId = thumbnail.getAttribute('data-ad-image');
                        if (adId && adId !== 'placeholder_new') {
                            const img = thumbnail.querySelector('img');
                            if (img && img.src && img.src.startsWith('data:image')) {
                                if (!customData.adImages) customData.adImages = {};
                                customData.adImages[adId] = img.src;
                                console.log(`‚úÖ Imagem Base64 extra√≠da do HTML: ${adId}`);
                            }
                        }
                    });
                    
                    // Garantir que file inputs existam ap√≥s extrair imagens
                    if (typeof ensureFileInputsExist === 'function') {
                        ensureFileInputsExist();
                    }
                    
                    // Reconfigurar edi√ß√£o de imagens ap√≥s garantir inputs
                    if (typeof setupAdImageEditing === 'function') {
                        setupAdImageEditing();
                    }
                    
                    // Garantir que bot√µes de deletar existam e estejam configurados
                    if (typeof setupDeleteButtons === 'function') {
                        setupDeleteButtons();
                        // Atualizar visibilidade dos bot√µes baseado no modo
                        if (typeof updateEditModeUI === 'function') {
                            updateEditModeUI();
                        }
                    }
                }, 200);
                
                // Reorganizar cards ap√≥s aplicar customiza√ß√µes para garantir placeholder se necess√°rio
                setTimeout(() => {
                    if (typeof reorganizeAdCards === 'function') {
                        reorganizeAdCards();
                    }
                }, 300);
            }, 500);
        }

        // Preparar elementos para edi√ß√£o
        function prepareEditMode() {
            // Encontrar todos os elementos edit√°veis
            const editables = [
                // Capa
                '.capa-title',
                '.capa-unidade',
                '.capa-periodo',
                
                // Resultados
                '.card-value',
                '.card-label',
                '.resultados-title',
                '.resultados-subtitle',
                
                // Ranking
                '.ranking-title',
                '.ranking-metrics-leads',
                '.ranking-metrics-cost',
                
                // Pr√≥ximos Passos
                '.proximos-title',
                '.proximos-subtitle',
                '.proximos-list li',
                
                // Obrigado
                '.obrigado-text'
            ];

            editables.forEach(selector => {
                const elements = document.querySelectorAll(selector);
                elements.forEach((element, index) => {
                    // Criar ID √∫nico
                    const editId = `${selector.replace(/[.#\s]/g, '_')}_${index}`;
                    element.setAttribute('data-edit-id', editId);
                    element.classList.add('editable');
                    element.setAttribute('data-editable', 'true');
                    
                    // Event listeners
                    element.addEventListener('click', () => {
                        if (isEditMode && !element.hasAttribute('contenteditable')) {
                            startEditing(element, editId);
                        }
                    });
                    
                    element.addEventListener('blur', () => {
                        stopEditing(element, editId);
                    });
                });
            });
            
            // Adicionar m√©tricas de an√∫ncios como edit√°veis
            setTimeout(() => {
                const adMetrics = document.querySelectorAll('[data-ad-leads], [data-ad-cost]');
                adMetrics.forEach((element) => {
                    const adId = element.getAttribute('data-ad-leads') || element.getAttribute('data-ad-cost');
                    const metricType = element.classList.contains('ranking-metrics-leads') ? 'leads' : 'cost';
                    const editId = `ad_${adId}_${metricType}`;
                    
                    element.setAttribute('data-edit-id', editId);
                    element.classList.add('editable');
                    
                    element.addEventListener('click', () => {
                        if (isEditMode && !element.hasAttribute('contenteditable')) {
                            startEditing(element, editId);
                        }
                    });
                    
                    element.addEventListener('blur', () => {
                        stopEditing(element, editId);
                    });
                });
            }, 100);
            
            // Garantir que file inputs existam para todos os an√∫ncios
            ensureFileInputsExist();
            
            // Atualizar UI baseado no modo
            updateEditModeUI();
            setupAdImageEditing();
        }
        
        // Garantir que file inputs existam para todos os an√∫ncios (necess√°rio ao carregar apresenta√ß√£o salva)
        function ensureFileInputsExist() {
            const thumbnails = document.querySelectorAll('.ranking-thumbnail[data-ad-image]');
            thumbnails.forEach(thumbnail => {
                const adId = thumbnail.getAttribute('data-ad-image');
                if (!adId || adId === 'placeholder_new') return;
                
                // Verificar se j√° existe file input
                let fileInput = document.querySelector(`[data-ad-input="${adId}"]`);
                if (!fileInput) {
                    // Criar file input se n√£o existir
                    const card = thumbnail.closest('.ranking-card');
                    if (card) {
                        fileInput = document.createElement('input');
                        fileInput.type = 'file';
                        fileInput.accept = 'image/*';
                        fileInput.className = 'ranking-image-input';
                        fileInput.setAttribute('data-ad-input', adId);
                        fileInput.style.display = 'none';
                        card.appendChild(fileInput);
                        console.log(`‚úÖ File input criado para an√∫ncio: ${adId}`);
                    }
                }
            });
        }
        
        // Atualizar UI baseado no modo
        function updateEditModeUI() {
            const editables = document.querySelectorAll('.editable');
            editables.forEach(el => {
                if (isEditMode) {
                    el.style.cursor = 'text';
                } else {
                    el.style.cursor = 'default';
                    el.removeAttribute('contenteditable');
                }
            });
            
            // Mostrar/ocultar bot√µes de deletar an√∫ncios (n√£o mostrar no placeholder)
            const deleteButtons = document.querySelectorAll('.ranking-card-delete');
            deleteButtons.forEach(btn => {
                const card = btn.closest('.ranking-card');
                // N√£o mostrar bot√£o de deletar no placeholder
                if (card && card.classList.contains('ranking-card-placeholder')) {
                    btn.style.display = 'none';
                } else {
                    btn.style.display = isEditMode ? 'flex' : 'none';
                }
            });
            
            // Adicionar/remover classe edit-mode nos thumbnails para controlar hover
            // Garantir que todos os thumbnails com data-ad-image tenham a classe ranking-thumbnail-editable
            const allThumbnails = document.querySelectorAll('.ranking-thumbnail[data-ad-image]');
            allThumbnails.forEach(thumbnail => {
                // Garantir que tem a classe necess√°ria
                if (!thumbnail.classList.contains('ranking-thumbnail-editable')) {
                    thumbnail.classList.add('ranking-thumbnail-editable');
                }
                
                if (isEditMode) {
                    thumbnail.classList.add('edit-mode');
                } else {
                    thumbnail.classList.remove('edit-mode');
                }
            });
        }
        
        // Configurar edi√ß√£o de imagens dos an√∫ncios
        function setupAdImageEditing() {
            // Garantir que todos os thumbnails tenham a classe necess√°ria
            const allThumbnails = document.querySelectorAll('.ranking-thumbnail[data-ad-image]');
            allThumbnails.forEach(thumbnail => {
                if (!thumbnail.classList.contains('ranking-thumbnail-editable')) {
                    thumbnail.classList.add('ranking-thumbnail-editable');
                }
            });
            
            const thumbnails = document.querySelectorAll('.ranking-thumbnail-editable');
            
            thumbnails.forEach(thumbnail => {
                const adId = thumbnail.getAttribute('data-ad-image');
                if (!adId) return;
                
                const fileInput = document.querySelector(`[data-ad-input="${adId}"]`);
                if (!fileInput) return;
                
                // Remover listeners antigos clonando o elemento
                const newThumbnail = thumbnail.cloneNode(true);
                thumbnail.parentNode.replaceChild(newThumbnail, thumbnail);
                
                // Remover listeners antigos do file input clonando
                const newFileInput = fileInput.cloneNode(true);
                fileInput.parentNode.replaceChild(newFileInput, fileInput);
                
                // Click para selecionar arquivo
                newThumbnail.addEventListener('click', (e) => {
                    if (isEditMode && !e.target.closest('.ranking-card-delete')) {
                        newFileInput.click();
                    }
                });
                
                // Drag & Drop
                newThumbnail.addEventListener('dragover', (e) => {
                    if (isEditMode) {
                        e.preventDefault();
                        newThumbnail.style.border = '2px solid #9333EA';
                        newThumbnail.style.backgroundColor = 'rgba(147, 51, 234, 0.1)';
                    }
                });
                
                newThumbnail.addEventListener('dragleave', () => {
                    newThumbnail.style.border = '';
                    newThumbnail.style.backgroundColor = '';
                });
                
                newThumbnail.addEventListener('drop', (e) => {
                    if (isEditMode) {
                        e.preventDefault();
                        newThumbnail.style.border = '';
                        newThumbnail.style.backgroundColor = '';
                        
                        const files = e.dataTransfer.files;
                        if (files.length > 0 && files[0].type.startsWith('image/')) {
                            handleImageUpload(files[0], adId, newThumbnail, newFileInput);
                        }
                    }
                });
                
                // File input change
                newFileInput.addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        handleImageUpload(e.target.files[0], adId, newThumbnail, newFileInput);
                        // Limpar o valor para permitir selecionar o mesmo arquivo novamente
                        e.target.value = '';
                    }
                });
            });
            
            // Configurar bot√µes de deletar
            setupDeleteButtons();
        }
        
        // Processar upload de imagem
        function handleImageUpload(file, adId, thumbnail, fileInput) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const imageUrl = e.target.result; // Base64
                
                // Atualizar imagem
                const existingImg = thumbnail.querySelector('img');
                if (existingImg) {
                    existingImg.src = imageUrl;
                    // Remover qualquer borda ou outline das imagens customizadas
                    existingImg.style.border = 'none';
                    existingImg.style.outline = 'none';
                    existingImg.style.boxShadow = 'none';
                    existingImg.style.borderRadius = '0';
                } else {
                    // Se n√£o tem img, criar uma
                    const placeholder = thumbnail.querySelector('div');
                    if (placeholder) {
                        thumbnail.innerHTML = `<img src="${imageUrl}" alt="An√∫ncio" style="width:100%;height:100%;object-fit:cover;border:none;outline:none;box-shadow:none;border-radius:0;">`;
                    } else {
                        // Se n√£o tem nada, criar img diretamente
                        thumbnail.innerHTML = `<img src="${imageUrl}" alt="An√∫ncio" style="width:100%;height:100%;object-fit:cover;border:none;outline:none;box-shadow:none;border-radius:0;">`;
                    }
                }
                
                // Remover placeholder class se existir
                thumbnail.classList.remove('ranking-thumbnail-placeholder');
                const card = thumbnail.closest('.ranking-card');
                if (card) {
                    card.classList.remove('ranking-card-placeholder');
                    
                    // Garantir que o bot√£o de deletar existe e est√° vis√≠vel (se em modo edi√ß√£o)
                    if (isEditMode) {
                        let deleteBtn = card.querySelector('.ranking-card-delete');
                        if (!deleteBtn) {
                            // Criar bot√£o de deletar se n√£o existir
                            deleteBtn = document.createElement('button');
                            deleteBtn.className = 'ranking-card-delete';
                            deleteBtn.style.cssText = 'position:absolute;top:10px;right:10px;z-index:10;width:32px;height:32px;background:rgba(239,68,68,0.9);border:none;border-radius:50%;color:white;cursor:pointer;display:flex;align-items:center;justify-content:center;';
                            deleteBtn.innerHTML = '<i class="fas fa-trash" style="font-size:14px;"></i>';
                            deleteBtn.title = 'Remover an√∫ncio';
                            card.style.position = 'relative';
                            card.appendChild(deleteBtn);
                        }
                        // Mostrar bot√£o de deletar
                        deleteBtn.style.display = 'flex';
                    }
                }
                
                // Salvar no customData
                if (!customData.adImages) customData.adImages = {};
                customData.adImages[adId] = imageUrl;
                
                // Se for placeholder_new, criar novo ID
                if (adId === 'placeholder_new') {
                    const newAdId = `ad_custom_${Date.now()}`;
                    thumbnail.setAttribute('data-ad-image', newAdId);
                    
                    // Verificar se o img existe antes de atualizar
                    const img = thumbnail.querySelector('img');
                    if (img) {
                        img.setAttribute('data-ad-image', newAdId);
                    }
                    
                    customData.adImages[newAdId] = imageUrl;
                    delete customData.adImages[adId];
                    
                    // Atualizar outros atributos
                    if (card) {
                        card.setAttribute('data-ad-id', newAdId);
                        
                        const leadsElement = card.querySelector('[data-ad-leads]');
                        if (leadsElement) {
                            leadsElement.setAttribute('data-ad-leads', newAdId);
                        }
                        
                        const costElement = card.querySelector('[data-ad-cost]');
                        if (costElement) {
                            costElement.setAttribute('data-ad-cost', newAdId);
                        }
                    }
                    
                    if (fileInput) {
                        fileInput.setAttribute('data-ad-input', newAdId);
                    }
                }
                
                // Reconfigurar bot√µes de deletar ap√≥s adicionar imagem
                setTimeout(() => {
                    setupDeleteButtons();
                }, 100);
                
                markAsChanged();
            };
            reader.readAsDataURL(file);
        }
        
        // Configurar bot√µes de deletar
        function setupDeleteButtons() {
            const deleteButtons = document.querySelectorAll('.ranking-card-delete');
            deleteButtons.forEach(btn => {
                // N√£o adicionar listener no placeholder
                const card = btn.closest('.ranking-card');
                if (card && card.classList.contains('ranking-card-placeholder')) {
                    return; // N√£o adicionar listener em placeholder
                }
                
                // Remover listeners antigos clonando o bot√£o
                const newBtn = btn.cloneNode(true);
                btn.parentNode.replaceChild(newBtn, btn);
                
                newBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    const currentCard = newBtn.closest('.ranking-card');
                    if (isEditMode && currentCard && !currentCard.classList.contains('ranking-card-placeholder')) {
                        if (confirm('Tem certeza que deseja remover este an√∫ncio?')) {
                            deleteAdCard(currentCard);
                        }
                    }
                });
            });
        }
        
        // Deletar card de an√∫ncio
        function deleteAdCard(card) {
            const adId = card.getAttribute('data-ad-id');
            
            // SEMPRE marcar como mudado ANTES de qualquer opera√ß√£o
            markAsChanged();
            
            // Remover do customData
            if (customData.adImages && customData.adImages[adId]) {
                delete customData.adImages[adId];
            }
            
            // Remover card
            card.remove();
            
            // Reorganizar cards e mostrar placeholder se necess√°rio
            reorganizeAdCards();
        }
        
        // Reorganizar cards ap√≥s deletar
        function reorganizeAdCards() {
            const grid = document.querySelector('.ranking-grid');
            if (!grid) return;
            
            const cards = Array.from(grid.querySelectorAll('.ranking-card:not(.ranking-card-placeholder)'));
            const placeholder = grid.querySelector('.ranking-card-placeholder');
            
            // Sempre manter 3 colunas para layout consistente
            grid.style.gridTemplateColumns = 'repeat(3, 1fr)';
            // Garantir que os cards mantenham o mesmo tamanho
            grid.style.gridAutoRows = 'auto';
            
            // Se tem menos de 3 cards, garantir que placeholder existe e est√° vis√≠vel
            if (cards.length < 3) {
                if (!placeholder) {
                    // Criar placeholder se n√£o existir
                    const placeholderHTML = `
                    <div class="ranking-card ranking-card-placeholder" data-ad-id="placeholder_new" style="display:flex;">
                        <div class="ranking-thumbnail ranking-thumbnail-editable ranking-thumbnail-placeholder" data-ad-image="placeholder_new" style="border:2px dashed #9333EA;background:#f9fafb;cursor:pointer;display:flex;align-items:center;justify-content:center;flex-direction:column;color:#9333EA;">
                            <i class="fas fa-plus-circle" style="font-size:48px;margin-bottom:8px;"></i>
                            <span style="font-size:14px;font-weight:500;">Clique ou arraste uma imagem</span>
                        </div>
                        <div class="ranking-metrics-bar">
                            <span class="ranking-metrics-leads" data-ad-leads="placeholder_new">0 Leads</span>
                            <span class="ranking-metrics-cost" data-ad-cost="placeholder_new">R$ 0,00</span>
                        </div>
                        <input type="file" accept="image/*" class="ranking-image-input" data-ad-input="placeholder_new" style="display:none;">
                    </div>
                    `;
                    grid.insertAdjacentHTML('beforeend', placeholderHTML);
                    // Reconfigurar edi√ß√£o de imagens ap√≥s criar placeholder
                    if (isEditMode) {
                        setTimeout(() => {
                            setupAdImageEditing();
                        }, 100);
                    }
                } else {
                    placeholder.style.display = 'flex';
                    // Esconder bot√£o de deletar do placeholder
                    const placeholderDeleteBtn = placeholder.querySelector('.ranking-card-delete');
                    if (placeholderDeleteBtn) {
                        placeholderDeleteBtn.style.display = 'none';
                    }
                }
            } else if (placeholder) {
                placeholder.style.display = 'none';
            }
            
            // Centralizar grid sem alterar tamanho dos cards
            if (cards.length === 1) {
                // Usar justify-content no grid container sem alterar o tamanho dos cards
                grid.style.justifyContent = 'center';
                grid.style.justifyItems = 'stretch';
            } else if (cards.length === 2) {
                grid.style.justifyContent = 'center';
                grid.style.justifyItems = 'stretch';
            } else {
                grid.style.justifyContent = '';
                grid.style.justifyItems = 'stretch';
            }
            
            // Reconfigurar edi√ß√£o de imagens ap√≥s reorganizar
            if (isEditMode) {
                setTimeout(() => {
                    setupAdImageEditing();
                }, 100);
            }
        }

        // Iniciar edi√ß√£o
        function startEditing(element, editId) {
            element.setAttribute('contenteditable', 'true');
            element.focus();
            
            // Selecionar texto
            const range = document.createRange();
            range.selectNodeContents(element);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
        }

        // Parar edi√ß√£o
        function stopEditing(element, editId) {
            element.removeAttribute('contenteditable');
            
            // Salvar altera√ß√£o
            const newValue = element.textContent.trim();
            
            // Obter valor original (da primeira renderiza√ß√£o ou do customData)
            if (!element.hasAttribute('data-original-value')) {
                // Primeira vez editando - salvar valor original
                const originalText = element.textContent.trim();
                element.setAttribute('data-original-value', originalText);
            }
            
            const originalValue = element.getAttribute('data-original-value') || '';
            
            // Detectar qualquer altera√ß√£o (adicionar, remover, modificar - mesmo que fique vazio)
            if (newValue !== originalValue) {
                // SEMPRE marcar como mudado ANTES de restaurar qualquer valor visual
                markAsChanged();
                
                if (newValue === '') {
                    // Se ficou vazio, remover do customData mas manter a mudan√ßa registrada
                    delete customData[editId];
                    // Restaurar valor original visualmente
                    element.textContent = originalValue;
                    element.setAttribute('data-original-value', originalValue);
                } else {
                    customData[editId] = newValue;
                }
                console.log(`üíæ Altera√ß√£o detectada: ${editId} (original: "${originalValue}" -> novo: "${newValue}")`);
            }
        }

        // Marcar como alterado
        function markAsChanged() {
            hasUnsavedChanges = true;
            saveButtonContainer.classList.remove('hidden');
            saveBtn.classList.remove('hidden');
            console.log('‚úÖ Bot√£o salvar habilitado');
        }

        // Salvar altera√ß√µes
        async function saveChanges() {
            if (!hasUnsavedChanges) {
                alert('Nenhuma altera√ß√£o para salvar');
                return;
            }

            saveChangesBtn.disabled = true;
            saveChangesBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Salvando...';

            try {
                // Aplicar customiza√ß√µes de imagens no HTML antes de salvar
                applyImageCustomizationsToHTML();
                
                // Limpar HTML antes de salvar (remover elementos de edi√ß√£o e otimizar)
                const cleanedHTML = await cleanHTMLForSave(presentationContainer.innerHTML);
                
                // Preparar customData para salvar (remover imagens Base64 grandes)
                const customDataToSave = { ...customData };
                
                // Remover imagens Base64 de customData.adImages (elas j√° est√£o no HTML)
                // Manter apenas refer√™ncia de quais an√∫ncios foram customizados
                if (customDataToSave.adImages) {
                    const adImagesReference = {};
                    // Guardar apenas IDs dos an√∫ncios customizados, sem as imagens Base64
                    Object.keys(customDataToSave.adImages).forEach(adId => {
                        adImagesReference[adId] = true; // Apenas marca√ß√£o, n√£o a imagem
                    });
                    customDataToSave.adImages = adImagesReference;
                }
                
                await presentationsService.updatePresentation(projectId, presentationId, {
                    customData: customDataToSave,
                    html: cleanedHTML,
                    updatedAt: new Date().toISOString()
                });

                hasUnsavedChanges = false;
                saveButtonContainer.classList.add('hidden');
                saveBtn.classList.add('hidden');
                saveChangesBtn.disabled = false;
                saveChangesBtn.innerHTML = '<i class="fas fa-save"></i> Salvar Altera√ß√µes';

                // Mostrar feedback
                showNotification('Altera√ß√µes salvas com sucesso!', 'success');

            } catch (error) {
                console.error('‚ùå Erro ao salvar:', error);
                saveChangesBtn.disabled = false;
                saveChangesBtn.innerHTML = '<i class="fas fa-save"></i> Salvar Altera√ß√µes';
                showNotification('Erro ao salvar altera√ß√µes', 'error');
            }
        }

        // Mostrar notifica√ß√£o
        function showNotification(message, type = 'success') {
            const notification = document.createElement('div');
            notification.className = `fixed top-4 right-4 px-6 py-3 rounded-lg shadow-lg z-50 ${
                type === 'success' ? 'bg-green-600 text-white' : 'bg-red-600 text-white'
            }`;
            notification.innerHTML = `
                <div class="flex items-center gap-2">
                    <i class="fas ${type === 'success' ? 'fa-check-circle' : 'fa-exclamation-circle'}"></i>
                    <span>${message}</span>
                </div>
            `;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.style.opacity = '0';
                notification.style.transition = 'opacity 0.3s';
                setTimeout(() => notification.remove(), 300);
            }, 3000);
        }

        // Toggle modo de edi√ß√£o
        toggleEditBtn.addEventListener('click', () => {
            isEditMode = !isEditMode;
            
            // Garantir que file inputs existam ao entrar em modo edi√ß√£o
            if (isEditMode && typeof ensureFileInputsExist === 'function') {
                ensureFileInputsExist();
            }
            updateEditModeUI();
            
            // Reconfigurar edi√ß√£o de imagens quando mudar modo
            if (isEditMode) {
                setupAdImageEditing();
            }
            
            toggleEditBtn.innerHTML = isEditMode 
                ? '<i class="fas fa-eye"></i> Modo Visualiza√ß√£o'
                : '<i class="fas fa-edit"></i> Modo Edi√ß√£o';
        });

        // Salvar altera√ß√µes
        saveChangesBtn.addEventListener('click', saveChanges);
        saveBtn.addEventListener('click', saveChanges);

        // Modo Apresenta√ß√£o
        presentBtn.addEventListener('click', () => {
            enterPresentationMode();
        });
        
        // Fun√ß√£o para entrar em modo apresenta√ß√£o
        async function enterPresentationMode() {
            if (isEditMode) {
                alert('Saia do modo edi√ß√£o antes de apresentar');
                return;
            }
            
            isPresentationMode = true;
            
            // Aplicar customiza√ß√µes de imagens antes de apresentar
            applyImageCustomizationsToHTML();
            
            // Obter HTML limpo (igual ao exportar PDF)
            const cleanHTML = presentationContainer.innerHTML;
            
            // Remover elementos de edi√ß√£o (igual ao print)
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = cleanHTML;
            tempDiv.querySelectorAll('.ranking-card-delete, .ranking-image-input').forEach(el => el.remove());
            tempDiv.querySelectorAll('.editable[contenteditable="true"]').forEach(el => {
                el.removeAttribute('contenteditable');
            });
            
            // IMPORTANTE: Mostrar modo apresenta√ß√£o ANTES de renderizar para ter o tamanho correto
            const presentationMode = document.getElementById('presentationMode');
            presentationMode.classList.add('active');
            
            // Aguardar um frame para o DOM atualizar e ter o tamanho correto do container
            await new Promise(resolve => requestAnimationFrame(resolve));
            
            // Renderizar no modo apresenta√ß√£o (igual ao print)
            await renderPresentationMode(tempDiv.innerHTML);
            
            // Adicionar listeners de teclado
            document.addEventListener('keydown', handlePresentationKeyboard);
            
            // Prevenir scroll da p√°gina
            document.body.style.overflow = 'hidden';
        }
        
        // Flag para prevenir m√∫ltiplas aplica√ß√µes do scale durante carregamento
        let isApplyingScale = false;
        
        // Armazenar o √∫ltimo scale v√°lido para evitar recalcular com viewports inv√°lidos
        let lastValidScale = 1.0;
        let isInitialLoad = true;
        let hasAppliedInitialScale = false;
        
        // Calcular scale para tela cheia mantendo propor√ß√£o (igual ao PDF viewer do Google)
        function calculateScale() {
            // Usar sempre window.innerWidth/Height (mais confi√°vel que container)
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            
            // Ignorar viewports muito pequenos (provavelmente DevTools ou outros elementos)
            if (viewportWidth < 800 || viewportHeight < 600) {
                console.warn(`‚ö†Ô∏è Viewport muito pequeno ignorado: ${viewportWidth}x${viewportHeight}, usando scale anterior: ${lastValidScale.toFixed(3)}`);
                return lastValidScale; // Retornar √∫ltimo scale v√°lido
            }
            
            // Ignorar viewports em modo retrato (altura > largura) durante apresenta√ß√£o
            // Apenas durante o carregamento inicial, depois aceitar qualquer orienta√ß√£o
            if (isInitialLoad && viewportHeight > viewportWidth) {
                console.warn(`‚ö†Ô∏è Viewport em modo retrato ignorado durante carregamento: ${viewportWidth}x${viewportHeight}, usando scale anterior: ${lastValidScale.toFixed(3)}`);
                return lastValidScale;
            }
            
            const slideWidth = 1280; // Tamanho original fixo
            const slideHeight = 720; // Tamanho original fixo
            
            // Calcular scale baseado na menor dimens√£o para manter propor√ß√£o
            const scaleX = viewportWidth / slideWidth;
            const scaleY = viewportHeight / slideHeight;
            // Usar 98% para preencher melhor a tela, deixando apenas uma pequena margem
            const scale = Math.min(scaleX, scaleY) * 0.98;
            
            // Armazenar scale v√°lido
            lastValidScale = scale;
            isInitialLoad = false; // Ap√≥s primeiro c√°lculo v√°lido, n√£o ignorar mais modo retrato
            
            console.log(`üìê Viewport: ${viewportWidth.toFixed(0)}x${viewportHeight.toFixed(0)}, Scale: ${scale.toFixed(3)}`);
            
            return Math.max(0.5, Math.min(scale, 2)); // Limitar entre 50% e 200%
        }
        
        // Aplicar scale em todos os slides (mant√©m propor√ß√µes originais)
        function applySlideScale(force = false) {
            // Durante carregamento inicial, aplicar apenas uma vez
            if (!force && hasAppliedInitialScale && isInitialLoad) {
                console.log('‚è∏Ô∏è Scale inicial j√° aplicado, ignorando durante carregamento...');
                return;
            }
            
            if (isApplyingScale) {
                console.log('‚è∏Ô∏è Scale j√° est√° sendo aplicado, ignorando...');
                return;
            }
            
            if (!slides || slides.length === 0) {
                console.warn('‚ö†Ô∏è Nenhum slide para aplicar scale');
                return;
            }
            
            isApplyingScale = true;
            
            const scale = calculateScale();
            // Scale sempre retorna um valor v√°lido (nunca null)
            
            console.log(`üìê Aplicando scale: ${scale.toFixed(3)} (slide original: 1280x720)`);
            slides.forEach((slide) => {
                // IMPORTANTE: Remover qualquer transform anterior antes de aplicar novo
                slide.style.removeProperty('transform');
                slide.style.removeProperty('width');
                slide.style.removeProperty('height');
                
                // Definir tamanho original primeiro
                slide.style.width = '1280px';
                slide.style.height = '720px';
                
                // Aplicar scale ap√≥s definir tamanho (mant√©m propor√ß√µes)
                // Usar translateZ(0) para for√ßar acelera√ß√£o de hardware
                slide.style.transform = `translateZ(0) scale(${scale})`;
            });
            console.log(`‚úÖ Scale aplicado em ${slides.length} slides`);
            
            // Marcar que scale inicial foi aplicado
            if (isInitialLoad) {
                hasAppliedInitialScale = true;
            }
            
            // Liberar flag ap√≥s um pequeno delay
            setTimeout(() => {
                isApplyingScale = false;
            }, 100);
        }
        
        // Renderizar HTML no modo apresenta√ß√£o (replicar EXATAMENTE a visualiza√ß√£o normal)
        async function renderPresentationMode(html) {
            const slidesContainer = document.getElementById('presentationSlides');
            
            // Limpar container
            slidesContainer.innerHTML = '';
            
            // Criar um div tempor√°rio para processar o HTML
            // IMPORTANTE: Usar um div com os mesmos estilos do presentation-container
            // para garantir que o HTML seja renderizado da mesma forma
            const tempDiv = document.createElement('div');
            tempDiv.style.position = 'absolute';
            tempDiv.style.visibility = 'hidden';
            tempDiv.style.width = '100%';
            tempDiv.innerHTML = html;
            document.body.appendChild(tempDiv);
            
            // Encontrar todas as p√°ginas (apenas diretas, n√£o aninhadas)
            const pages = tempDiv.querySelectorAll(':scope > .page');
            
            console.log(`üìÑ Encontradas ${pages.length} p√°ginas no HTML`);
            
            // Para cada p√°gina, clonar mantendo TODOS os estilos e estrutura
            pages.forEach((page, index) => {
                // Clonar a p√°gina COM todos os estilos computados (deep clone)
                const pageClone = page.cloneNode(true);
                
                // IMPORTANTE: Preservar todos os estilos inline e classes
                // A p√°gina j√° tem a classe .page com todos os estilos do style.css
                // Adicionar classe slide mantendo a classe page
                pageClone.classList.add('slide');
                
                // Adicionar ao container
                slidesContainer.appendChild(pageClone);
                
                console.log(`  ‚úÖ Slide ${index + 1} criado (classes: ${pageClone.className})`);
            });
            
            // Remover div tempor√°rio
            document.body.removeChild(tempDiv);
            
            // Armazenar slides
            slides = Array.from(slidesContainer.querySelectorAll('.slide'));
            
            console.log(`‚úÖ ${slides.length} slides renderizados no modo apresenta√ß√£o`);
            
            // IMPORTANTE: Aguardar um frame para garantir que o DOM foi atualizado
            await new Promise(resolve => requestAnimationFrame(resolve));
            
            // Aguardar fontes e imagens carregarem
            await document.fonts.ready;
            await waitForImages('.presentation-mode img');
            
            // Aguardar um pouco mais para garantir que o DOM est√° totalmente renderizado
            await new Promise(resolve => setTimeout(resolve, 200));
            
            // Aplicar scale para tela cheia (mant√©m propor√ß√µes originais)
            // Aplicar apenas uma vez ap√≥s tudo carregar (force = true para garantir)
            applySlideScale(true);
            
            // Marcar que carregamento inicial terminou ap√≥s 2 segundos
            setTimeout(() => {
                isInitialLoad = false;
                console.log('‚úÖ Carregamento inicial conclu√≠do, resize habilitado');
            }, 2000);
            
            // Aplicar scale quando redimensionar (com debounce mais longo para evitar m√∫ltiplas chamadas)
            // IMPORTANTE: N√£o adicionar listener de resize durante carregamento inicial
            // Adicionar apenas ap√≥s 2 segundos para evitar chamadas durante renderiza√ß√£o
            setTimeout(() => {
                let resizeTimeout;
                const resizeHandler = () => {
                    // Ignorar resize durante carregamento inicial
                    if (isInitialLoad) {
                        console.log('‚è∏Ô∏è Resize ignorado durante carregamento inicial');
                        return;
                    }
                    
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => {
                        // Verificar se ainda est√° no modo apresenta√ß√£o
                        const presentationMode = document.getElementById('presentationMode');
                        if (presentationMode && presentationMode.classList.contains('active')) {
                            applySlideScale();
                        }
                    }, 500); // Debounce maior para evitar m√∫ltiplas chamadas
                };
                window.addEventListener('resize', resizeHandler);
                // Armazenar handler para remover depois
                window.presentationResizeHandler = resizeHandler;
                console.log('‚úÖ Listener de resize adicionado');
            }, 2000); // Adicionar listener apenas ap√≥s 2 segundos
            
            // Atualizar contador
            document.getElementById('totalSlides').textContent = slides.length;
            
            // Ir para o primeiro slide
            if (slides.length > 0) {
                goToSlide(0);
            } else {
                console.error('‚ùå Nenhum slide foi criado!');
            }
        }
        
        
        // Fun√ß√£o para sair do modo apresenta√ß√£o
        function exitPresentationMode() {
            isPresentationMode = false;
            
            const presentationMode = document.getElementById('presentationMode');
            presentationMode.classList.remove('active');
            
            // Remover listeners de teclado
            document.removeEventListener('keydown', handlePresentationKeyboard);
            
            // Remover listener de resize
            if (window.presentationResizeHandler) {
                window.removeEventListener('resize', window.presentationResizeHandler);
                delete window.presentationResizeHandler;
            }
            
            // Restaurar scroll
            document.body.style.overflow = '';
            
            // Limpar slides
            slides = [];
            currentSlideIndex = 0;
        }
        
        
        // Ir para slide espec√≠fico
        function goToSlide(index) {
            if (index < 0 || index >= slides.length) {
                console.warn(`‚ö†Ô∏è √çndice inv√°lido: ${index} (total: ${slides.length})`);
                return;
            }
            
            // Esconder todos os slides
            slides.forEach(slide => {
                slide.classList.remove('active');
            });
            
            // Mostrar slide atual
            currentSlideIndex = index;
            if (slides[index]) {
                slides[index].classList.add('active');
            }
            
            // Atualizar contador
            document.getElementById('currentSlideNumber').textContent = index + 1;
            
            // Atualizar bot√µes
            document.getElementById('prevSlideBtn').disabled = index === 0;
            document.getElementById('nextSlideBtn').disabled = index === slides.length - 1;
        }
        
        // Pr√≥ximo slide
        function nextSlide() {
            if (currentSlideIndex < slides.length - 1) {
                goToSlide(currentSlideIndex + 1);
            }
        }
        
        // Slide anterior
        function prevSlide() {
            if (currentSlideIndex > 0) {
                goToSlide(currentSlideIndex - 1);
            }
        }
        
        // Handler de teclado para modo apresenta√ß√£o
        function handlePresentationKeyboard(e) {
            if (!isPresentationMode) return;
            
            switch(e.key) {
                case 'ArrowRight':
                case 'ArrowDown':
                case 'PageDown':
                    e.preventDefault();
                    nextSlide();
                    break;
                case 'ArrowLeft':
                case 'ArrowUp':
                case 'PageUp':
                    e.preventDefault();
                    prevSlide();
                    break;
                case 'Escape':
                    e.preventDefault();
                    exitPresentationMode();
                    break;
            }
        }
        
        // Bot√µes de navega√ß√£o (adicionar listeners quando necess√°rio)
        function setupPresentationButtons() {
            const exitBtn = document.getElementById('exitPresentationBtn');
            const prevBtn = document.getElementById('prevSlideBtn');
            const nextBtn = document.getElementById('nextSlideBtn');
            
            if (exitBtn) {
                exitBtn.addEventListener('click', exitPresentationMode);
            }
            if (prevBtn) {
                prevBtn.addEventListener('click', prevSlide);
            }
            if (nextBtn) {
                nextBtn.addEventListener('click', nextSlide);
            }
        }
        
        // Configurar bot√µes quando o DOM estiver pronto
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', setupPresentationButtons);
        } else {
            setupPresentationButtons();
        }
        
        // Exportar PDF
        exportPDFBtn.addEventListener('click', () => {
            // Aplicar customiza√ß√µes de imagens antes de exportar
            applyImageCustomizationsToHTML();
            
            // Remover classes e atributos de edi√ß√£o
            const editables = document.querySelectorAll('.editable');
            editables.forEach(el => {
                el.classList.remove('editable');
                el.removeAttribute('data-editable');
                el.removeAttribute('data-edit-id');
                el.removeAttribute('contenteditable');
                el.style.cursor = '';
                el.style.outline = '';
                el.style.backgroundColor = '';
            });
            
            // Remover bot√µes de deletar e inputs de arquivo
            document.querySelectorAll('.ranking-card-delete').forEach(btn => btn.remove());
            document.querySelectorAll('.ranking-image-input').forEach(input => input.remove());
            
            // Remover placeholder se existir
            const placeholder = document.querySelector('.ranking-card-placeholder');
            if (placeholder) placeholder.remove();
            
            // Obter HTML limpo (sem elementos de edi√ß√£o)
            const cleanHTML = presentationContainer.innerHTML;
            
            // Restaurar elementos para edi√ß√£o (caso o usu√°rio queira editar depois)
            setTimeout(() => {
                // Garantir que file inputs existam
                if (typeof ensureFileInputsExist === 'function') {
                    ensureFileInputsExist();
                }
                prepareEditMode();
            }, 100);
            
            // Salvar em sessionStorage para o apresentacao-print.html usar
            sessionStorage.setItem('presentationPrintPayload', JSON.stringify({
                html: cleanHTML
            }));
            
            // Abrir p√°gina de impress√£o
            window.open(`apresentacao-print.html?mode=session&auto=1`, '_blank');
        });
        
        // Aplicar customiza√ß√µes de imagens ao HTML antes de salvar
        function applyImageCustomizationsToHTML() {
            if (!customData.adImages) return;
            
            Object.keys(customData.adImages).forEach(adId => {
                const thumbnail = document.querySelector(`[data-ad-image="${adId}"]`);
                if (thumbnail) {
                    const img = thumbnail.querySelector('img');
                    if (img && customData.adImages[adId]) {
                        img.src = customData.adImages[adId];
                        // Remover bordas das imagens customizadas
                        img.style.border = 'none';
                        img.style.outline = 'none';
                        img.style.boxShadow = 'none';
                        img.style.borderRadius = '0';
                    }
                }
            });
        }
        
        // Comprimir imagem Base64 reduzindo qualidade
        async function compressBase64Image(base64String, maxWidth = 800, quality = 0.7) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    let width = img.width;
                    let height = img.height;
                    
                    // Redimensionar se necess√°rio
                    if (width > maxWidth) {
                        height = (height * maxWidth) / width;
                        width = maxWidth;
                    }
                    
                    canvas.width = width;
                    canvas.height = height;
                    
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, width, height);
                    
                    // Converter para JPEG com qualidade reduzida
                    const compressed = canvas.toDataURL('image/jpeg', quality);
                    resolve(compressed);
                };
                img.onerror = () => resolve(base64String); // Se falhar, retorna original
                img.src = base64String;
            });
        }
        
        // Limpar e otimizar HTML antes de salvar para reduzir tamanho
        async function cleanHTMLForSave(html) {
            // Criar um elemento tempor√°rio para manipular o HTML
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = html;
            
            // Remover elementos de edi√ß√£o desnecess√°rios
            tempDiv.querySelectorAll('.ranking-card-delete').forEach(el => el.remove());
            tempDiv.querySelectorAll('.ranking-image-input').forEach(el => el.remove());
            tempDiv.querySelectorAll('.ranking-card-placeholder').forEach(el => el.remove());
            tempDiv.querySelectorAll('[contenteditable]').forEach(el => el.removeAttribute('contenteditable'));
            tempDiv.querySelectorAll('[data-edit-id]').forEach(el => el.removeAttribute('data-edit-id'));
            tempDiv.querySelectorAll('.editable').forEach(el => el.classList.remove('editable'));
            
            // Comprimir imagens Base64 se necess√°rio
            const images = tempDiv.querySelectorAll('.ranking-thumbnail img');
            for (const img of images) {
                const src = img.getAttribute('src');
                if (src && src.startsWith('data:image')) {
                    // Comprimir imagem Base64 para reduzir tamanho
                    const compressed = await compressBase64Image(src, 800, 0.75);
                    img.setAttribute('src', compressed);
                }
            }
            
            // Minificar HTML removendo espa√ßos extras
            let cleaned = tempDiv.innerHTML;
            
            // Remover m√∫ltiplos espa√ßos em branco e quebras de linha extras
            cleaned = cleaned.replace(/>\s+</g, '><');
            cleaned = cleaned.replace(/\s+/g, ' ');
            
            // Verificar tamanho do HTML
            const htmlSize = new Blob([cleaned]).size;
            console.log(`üìä Tamanho do HTML ap√≥s limpeza: ${(htmlSize / 1024).toFixed(2)} KB`);
            
            // Se ainda estiver muito grande (>950KB), comprimir mais agressivamente
            if (htmlSize > 950 * 1024) {
                console.warn('‚ö†Ô∏è HTML ainda muito grande, comprimindo imagens mais agressivamente...');
                const tempDiv2 = document.createElement('div');
                tempDiv2.innerHTML = cleaned;
                const images2 = tempDiv2.querySelectorAll('.ranking-thumbnail img');
                for (const img of images2) {
                    const src = img.getAttribute('src');
                    if (src && src.startsWith('data:image')) {
                        const compressed = await compressBase64Image(src, 600, 0.6);
                        img.setAttribute('src', compressed);
                    }
                }
                cleaned = tempDiv2.innerHTML;
                cleaned = cleaned.replace(/>\s+</g, '><');
                cleaned = cleaned.replace(/\s+/g, ' ');
                const finalSize = new Blob([cleaned]).size;
                console.log(`üìä Tamanho final do HTML: ${(finalSize / 1024).toFixed(2)} KB`);
            }
            
            return cleaned;
        }

        // Carregar quando autenticado
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                await loadPresentation();
            } else {
                window.location.href = '/login.html';
            }
        });
    </script>
    <script type="module">
        import { initSidebar } from './components/sidebar.js';
        initSidebar();
    </script>
</body>
</html>

